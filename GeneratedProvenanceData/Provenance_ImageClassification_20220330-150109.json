{
  "prefix": {
    "experimentinfo": "experimentinfo.org",
    "hardwareinfo": "hardwareinfo.org",
    "packages": "packages.org",
    "dataingestion": "dataingestion.org",
    "datapreparation": "datapreparation.org",
    "datasegregation": "datasegregation.org",
    "modelparameters": "modelparameters.org",
    "training": "training.org",
    "evaluation": "evaluation.org",
    "default": "provenanceexample.org"
  },
  "entity": {
    "experiment_info": {
      "experimentinfo:author": "Tarek Al Mustafa",
      "experimentinfo:email": "tarek.almustafa@uni-jena.de",
      "experimentinfo:title": "Image Classification",
      "experimentinfo:creation_date": "2022-03-30",
      "experimentinfo:task_type": "ImageClassification_pytorch"
    },
    "hardware_info": {
      "hardwareinfo:Python Version": "3.9.7.final.0 (64 bit)",
      "hardwareinfo:CPU": "AMD Ryzen 7 3700X 8-Core Processor",
      "hardwareinfo:RAM": "15.95GB",
      "hardwareinfo:Operating System": "Windows 10 Version: 10.0.19041 Machine: AMD64",
      "hardwareinfo:GPUs": "[(0, 'NVIDIA GeForce GTX 1060 6GB')]"
    },
    "packages": {
      "packages:numpy": "1.22.2",
      "packages:ipywidgets": "7.6.5",
      "packages:torch": "1.10.2+cpu",
      "packages:torchvision": "0.11.3+cpu",
      "packages:pytorch-ignite": "0.4.6",
      "packages:gputil": "1.4.0",
      "packages:psutil": "5.9.0",
      "packages:py-cpuinfo": "py-cpuinfo                    8.0.0",
      "packages:prov": "2.0.0"
    },
    "data_ingestion": {
      "dataingestion:data_format": "Public dataset",
      "dataingestion:dataset_id": "MNIST",
      "dataingestion:feature_classes": {
        "$": 10,
        "type": "xsd:int"
      },
      "dataingestion:training_samples": {
        "$": 60000,
        "type": "xsd:int"
      },
      "dataingestion:testing_samples": {
        "$": 10000,
        "type": "xsd:int"
      },
      "dataingestion:root_location": "    Root location: ./data"
    },
    "data_preparation": {
      "datapreparation:preprocessing": "[]"
    },
    "data_segregation": {
      "datasegregation:training_dataset": "<bound method MNIST.__len__ of Dataset MNIST\n    Number of datapoints: 60000\n    Root location: ./data\n    Split: Train\n    StandardTransform\nTransform: Compose(\n               Resize(size=256, interpolation=bilinear, max_size=None, antialias=None)\n               CenterCrop(size=(224, 224))\n               ToTensor()\n               Lambda()\n           )>",
      "datasegregation:testing_dataset": "<bound method MNIST.__len__ of Dataset MNIST\n    Number of datapoints: 10000\n    Root location: ./data\n    Split: Test\n    StandardTransform\nTransform: Compose(\n               Resize(size=256, interpolation=bilinear, max_size=None, antialias=None)\n               CenterCrop(size=(224, 224))\n               ToTensor()\n               Lambda()\n           )>"
    },
    "model_parameters": {
      "modelparameters:model_name": "resnet18",
      "modelparameters:save_checkpoint": {
        "$": 0,
        "type": "xsd:int"
      },
      "modelparameters:pretrained": {
        "$": 0,
        "type": "xsd:int"
      },
      "modelparameters:gpu_enable": {
        "$": 1,
        "type": "xsd:int"
      },
      "modelparameters:modelParameters": "ResNet(\n  (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)\n  (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (relu): ReLU(inplace=True)\n  (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False)\n  (layer1): Sequential(\n    (0): BasicBlock(\n      (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n    (1): BasicBlock(\n      (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n  )\n  (layer2): Sequential(\n    (0): BasicBlock(\n      (conv1): Conv2d(64, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)\n      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (downsample): Sequential(\n        (0): Conv2d(64, 128, kernel_size=(1, 1), stride=(2, 2), bias=False)\n        (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n    )\n    (1): BasicBlock(\n      (conv1): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n  )\n  (layer3): Sequential(\n    (0): BasicBlock(\n      (conv1): Conv2d(128, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)\n      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (downsample): Sequential(\n        (0): Conv2d(128, 256, kernel_size=(1, 1), stride=(2, 2), bias=False)\n        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n    )\n    (1): BasicBlock(\n      (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n  )\n  (layer4): Sequential(\n    (0): BasicBlock(\n      (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)\n      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (downsample): Sequential(\n        (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)\n        (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      )\n    )\n    (1): BasicBlock(\n      (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (relu): ReLU(inplace=True)\n      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n    )\n  )\n  (avgpool): AdaptiveAvgPool2d(output_size=(1, 1))\n  (fc): Linear(in_features=512, out_features=1000, bias=True)\n)",
      "modelparameters:loss_function": "nn.CrossEntropyLoss()",
      "modelparameters:optimizer": "optim.Adam",
      "modelparameters:optimizer_learning_rate": {
        "$": 0.001,
        "type": "xsd:double"
      },
      "modelparameters:num_classes": {
        "$": 1000,
        "type": "xsd:int"
      }
    },
    "training": {
      "training:batch_size": {
        "$": 128,
        "type": "xsd:int"
      },
      "training:epochs": {
        "$": 1,
        "type": "xsd:int"
      },
      "training:train_metrics": "State:\n\titeration: 469\n\tepoch: 1\n\tepoch_length: 469\n\tmax_epochs: 1\n\toutput: 0.06777133792638779\n\tbatch: <class 'list'>\n\tmetrics: <class 'dict'>\n\tdataloader: <class 'torch.utils.data.dataloader.DataLoader'>\n\tseed: <class 'NoneType'>\n\ttimes: <class 'dict'>\n",
      "training:print_progress": {
        "$": 1,
        "type": "xsd:int"
      }
    },
    "evaluation": {
      "evaluation:accuracy": {
        "$": 0.9818,
        "type": "xsd:double"
      },
      "evaluation:loss": {
        "$": 0.058511102294921874,
        "type": "xsd:double"
      }
    }
  },
  "activity": {
    "set_experiment_info()": {
      "prov:startTime": "2022-03-30T13:48:47.440517"
    },
    "date.today()": {},
    "set_hardware_info()": {
      "prov:startTime": "2022-03-30T13:48:50.156116"
    },
    "platform.uname()": {},
    "cpuinfo.get_cpu_info()": {},
    "svmem.total": {},
    "get_size(svmem.total)": {},
    "GPUtil.getGPUs()": {},
    "set_packages()": {
      "prov:startTime": "2022-03-30T13:48:51.825192"
    },
    "{package_name}.__version__": {},
    "!pip list | grep -i py-cpuinfo": {},
    "set_data_ingestion()": {
      "prov:startTime": "2022-03-30T13:48:51.857221"
    },
    "{dataset}.__len__()": {},
    "set_data_preparation()": {
      "prov:startTime": "2022-03-30T13:48:51.872234"
    },
    "set_data_segregation()": {
      "prov:startTime": "2022-03-30T13:48:51.905265"
    },
    "set_model_parameters()": {
      "prov:startTime": "2022-03-30T13:48:52.024372"
    },
    "set_training()": {
      "prov:startTime": "2022-03-30T15:01:09.889398"
    },
    "set_evaluation()": {
      "prov:startTime": "2022-03-30T15:01:09.911414"
    }
  },
  "wasGeneratedBy": {
    "_:id1": {
      "prov:entity": "experiment_info",
      "prov:activity": "set_experiment_info()"
    },
    "_:id4": {
      "prov:entity": "hardware_info",
      "prov:activity": "set_hardware_info()"
    },
    "_:id10": {
      "prov:entity": "packages",
      "prov:activity": "set_packages()"
    },
    "_:id13": {
      "prov:entity": "data_ingestion",
      "prov:activity": "set_data_ingestion()"
    },
    "_:id15": {
      "prov:entity": "data_preparation",
      "prov:activity": "set_data_preparation()"
    },
    "_:id19": {
      "prov:entity": "data_segregation",
      "prov:activity": "set_data_segregation()"
    },
    "_:id22": {
      "prov:entity": "model_parameters",
      "prov:activity": "set_model_parameters()"
    },
    "_:id24": {
      "prov:entity": "training",
      "prov:activity": "set_training()"
    },
    "_:id27": {
      "prov:entity": "evaluation",
      "prov:activity": "set_evaluation()"
    }
  },
  "wasAssociatedWith": {
    "_:id2": {
      "prov:activity": "experiment_info",
      "prov:agent": "Tarek Al Mustafa"
    }
  },
  "agent": {
    "Tarek Al Mustafa": {}
  },
  "wasInformedBy": {
    "_:id3": {
      "prov:informed": "set_experiment_info()",
      "prov:informant": "date.today()"
    },
    "_:id5": {
      "prov:informed": "set_hardware_info()",
      "prov:informant": "platform.uname()"
    },
    "_:id6": {
      "prov:informed": "set_hardware_info()",
      "prov:informant": "cpuinfo.get_cpu_info()"
    },
    "_:id7": {
      "prov:informed": "set_hardware_info()",
      "prov:informant": "svmem.total"
    },
    "_:id8": {
      "prov:informed": "svmem.total",
      "prov:informant": "get_size(svmem.total)"
    },
    "_:id9": {
      "prov:informed": "set_hardware_info()",
      "prov:informant": "GPUtil.getGPUs()"
    },
    "_:id11": {
      "prov:informed": "set_packages()",
      "prov:informant": "{package_name}.__version__"
    },
    "_:id12": {
      "prov:informed": "set_packages()",
      "prov:informant": "!pip list | grep -i py-cpuinfo"
    },
    "_:id14": {
      "prov:informed": "set_data_ingestion()",
      "prov:informant": "{dataset}.__len__()"
    },
    "_:id17": {
      "prov:informed": "str(dataInfo).splitlines()[2]",
      "prov:informant": "{dataset}.__len__()"
    },
    "_:id18": {
      "prov:informed": "set_data_preparation()",
      "prov:informant": "str(dataInfo).splitlines()[2]"
    },
    "_:id21": {
      "prov:informed": "set_data_segregation()",
      "prov:informant": "{dataset}.__len__()"
    }
  },
  "used": {
    "_:id16": {
      "prov:activity": "set_data_preparation()",
      "prov:entity": "data_ingestion"
    },
    "_:id20": {
      "prov:activity": "set_data_segregation()",
      "prov:entity": "data_preparation"
    },
    "_:id23": {
      "prov:activity": "set_model_parameters()",
      "prov:entity": "data_ingestion"
    },
    "_:id25": {
      "prov:activity": "set_training()",
      "prov:entity": "model_parameters"
    },
    "_:id26": {
      "prov:activity": "set_training()",
      "prov:entity": "data_segregation"
    },
    "_:id28": {
      "prov:activity": "set_evaluation()",
      "prov:entity": "training"
    }
  }
}